###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.10194/W32 for 8051         24/Nov/2016  14:18:02 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  E:\work\zigbee\ZStack-Smart-2.5.2b\Components\hal\ #
#                          target\CC2530EB\hal_key.c                          #
#    Command line       =  -f E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zst #
#                          ack\Applications\SmartApp\CC2530DB\Devices\..\..\. #
#                          .\..\Tools\CC2530DB\f8wCoord.cfg (-DCPU32MHZ       #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK     #
#                          -DSSA_CONNECTOR) -f E:\work\zigbee\ZStack-Smart-2. #
#                          5.2b\Projects\zstack\Applications\SmartApp\CC2530D #
#                          B\Devices\..\..\..\..\Tools\CC2530DB\f8wConfig.cfg #
#                           (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=1     #
#                          -DREFLECTOR -DDEFAULT_CHANLIST=0x00000800          #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=600         #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 E:\work\zigbee\ZStack-Smart #
#                          -2.5.2b\Components\hal\target\CC2530EB\hal_key.c   #
#                          -D SECURE=1 -D ZTOOL_P1 -D DEVICE_TYPE_ID=0xFE -D  #
#                          SIGNAL_AMPLIFIER_SETTING -D                        #
#                          xPOWER_AMPLIFIER_POSITION_1 -D xNWK_AUTO_POLL -D   #
#                          xHAL_UART_DMA=2 -D xHAL_UART_DMA_ALT1 -D           #
#                          xJIAJU_BUILDIN -D MT_TASK -D MT_SYS_FUNC -D        #
#                          MT_ZDO_FUNC -D NV_INIT -D NV_RESTORE -lC           #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\bin\DemoBaseZC\Lis #
#                          t\ -lA E:\work\zigbee\ZStack-Smart-2.5.2b\Projects #
#                          \zstack\Applications\SmartApp\CC2530DB\bin\DemoBas #
#                          eZC\List\ --diag_suppress Pe001,Pa010 -o           #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\bin\DemoBaseZC\Obj #
#                          \ -e --debug --core=plain --dptr=16,1              #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zst #
#                          ack\Applications\SmartApp\CC2530DB\Devices\ -I     #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\Sour #
#                          ce\Common\ -I E:\work\zigbee\ZStack-Smart-2.5.2b\P #
#                          rojects\zstack\Applications\SmartApp\CC2530DB\Devi #
#                          ces\..\..\Source\Connector\ -I                     #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\Sour #
#                          ce\\EndNode\ -I E:\work\zigbee\ZStack-Smart-2.5.2b #
#                          \Projects\zstack\Applications\SmartApp\CC2530DB\De #
#                          vices\..\..\Source\Board\ -I                       #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\Sour #
#                          ce\Manage\ -I E:\work\zigbee\ZStack-Smart-2.5.2b\P #
#                          rojects\zstack\Applications\SmartApp\CC2530DB\Devi #
#                          ces\..\..\Source\Manage\Callbacks\ -I              #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\Sour #
#                          ce\Manage\debug\ -I E:\work\zigbee\ZStack-Smart-2. #
#                          5.2b\Projects\zstack\Applications\SmartApp\CC2530D #
#                          B\Devices\..\..\Source\Manage\HeartBeat\ -I        #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\Sour #
#                          ce\Manage\incode\ -I E:\work\zigbee\ZStack-Smart-2 #
#                          .5.2b\Projects\zstack\Applications\SmartApp\CC2530 #
#                          DB\Devices\..\..\..\..\ZMain\TI2530DB\ -I          #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\hal\include\ -I                 #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\hal\target\CC2530EB\ -I         #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\mac\include\ -I                 #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\mac\high_level\ -I              #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\ -I         #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\single_chip #
#                          \ -I E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\z #
#                          stack\Applications\SmartApp\CC2530DB\Devices\..\.. #
#                          \..\..\..\..\Components\mt\ -I                     #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\osal\include\ -I                #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\services\saddr\ -I              #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\services\sdata\ -I              #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\stack\af\ -I                    #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\stack\nwk\ -I                   #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\stack\sapi\ -I                  #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\stack\sec\ -I                   #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\stack\sys\ -I                   #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\stack\zdo\ -I                   #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\zmac\ -I                        #
#                          E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\Devices\..\..\..\. #
#                          .\..\..\Components\zmac\f8w\ -Oh                   #
#                          --require_prototypes                               #
#    List file          =  E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\bin\DemoBaseZC\Lis #
#                          t\hal_key.lst                                      #
#    Object file        =  E:\work\zigbee\ZStack-Smart-2.5.2b\Projects\zstack #
#                          \Applications\SmartApp\CC2530DB\bin\DemoBaseZC\Obj #
#                          \hal_key.r51                                       #
#                                                                             #
#                                                                             #
###############################################################################

E:\work\zigbee\ZStack-Smart-2.5.2b\Components\hal\target\CC2530EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2010-09-15 19:02:45 -0700 (Wed, 15 Sep 2010) $
      4            Revision:       $Revision: 23815 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81          Modify by Sam_Chen
     82          Date:2015-03-03
     83          **************************************************************************************************/
     84          
     85          /**************************************************************************************************
     86           *                                            INCLUDES
     87           **************************************************************************************************/
     88          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr P0IEN
   \                     P0IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     89          #include "hal_defs.h"
     90          #include "hal_types.h"
     91          #include "hal_board.h"
     92          #include "hal_drivers.h"
     93          #include "hal_adc.h"
     94          #include "hal_key.h"
     95          #include "hal_led.h"
     96          #include "hal_uart.h"
     97          #include "osal.h"
     98          
     99          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    100          
    101          /**************************************************************************************************
    102           *                                              MACROS
    103           **************************************************************************************************/
    104          
    105          /**************************************************************************************************
    106           *                                            CONSTANTS
    107           **************************************************************************************************/
    108          #define HAL_KEY_RISING_EDGE   0
    109          #define HAL_KEY_FALLING_EDGE  1
    110          
    111          #define HAL_KEY_DEBOUNCE_VALUE  25
    112          
    113          /* CPU port interrupt */
    114          #define HAL_KEY_CPU_PORT_0_IF P0IF
    115          #define HAL_KEY_CPU_PORT_1_IF P1IF
    116          #define HAL_KEY_CPU_PORT_2_IF P2IF
    117          
    118          #ifdef KEY_PUSH_PORT_1_BUTTON
    119          #if !defined(PUSH_PORT_1_POLARITY) || !defined(HAL_KEY_PORT_1_BITS)
    120          #error lack of some macro be defined when use "KEY_PUSH_PORT_1_BUTTON"!
    121          #endif
    122          
    123          /* KEY SW at port 1 */
    124          #define HAL_KEY_PORT_1_SEL	P1SEL
    125          #define HAL_KEY_PORT_1_DIR	P1DIR
    126          #define HAL_KEY_PORT_1_ICTL	P1IEN
    127          #define HAL_KEY_PORT_1_IEN 	IEN2
    128          #define HAL_KEY_PORT_1_IENBITS  BV(4)
    129          #define HAL_KEY_PORT_1_PXIFG	P1IFG
    130          
    131          #define HAL_KEY_PORT_1_ICTLBITS		HAL_KEY_PORT_1_BITS
    132          
    133          #define HAL_KEY_PUSH_PORT_1_BUTTON()	((PUSH_PORT_1_POLARITY(P1)) & HAL_KEY_PORT_1_BITS)
    134          #endif
    135          
    136          /* SW_6 is at P0.1 */
    137          #define HAL_KEY_SW_6_PORT   P0
    138          #ifndef KEY_PUSH_PORT_0_BUTTON
    139          #define HAL_KEY_SW_6_BIT    BV(1)
    140          #else
    141          /* SW_6 change to P0.5 */
    142          #define HAL_KEY_SW_6_BIT    PUSH1_BV
    143          #endif
    144          #define HAL_KEY_SW_6_SEL    P0SEL
    145          #define HAL_KEY_SW_6_DIR    P0DIR
    146          
    147          /* edge interrupt */
    148          #define HAL_KEY_SW_6_EDGEBIT  BV(0)
    149          #define HAL_KEY_SW_6_EDGE     HAL_KEY_FALLING_EDGE
    150          
    151          
    152          /* SW_6 interrupts */
    153          #define HAL_KEY_SW_6_IEN      IEN1  /* CPU interrupt mask register */
    154          #define HAL_KEY_SW_6_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    155          #define HAL_KEY_SW_6_ICTL     P0IEN /* Port Interrupt Control register */
    156          #ifndef KEY_PUSH_PORT_0_BUTTON
    157          #define HAL_KEY_SW_6_ICTLBIT  BV(1) /* P0IEN - P0.1 enable/disable bit */
    158          #else
    159          #define HAL_KEY_SW_6_ICTLBIT  PUSH1_BV /* P0IEN - P0.5 enable/disable bit */
    160          #endif
    161          #define HAL_KEY_SW_6_PXIFG    P0IFG /* Interrupt flag at source */
    162          
    163          /* Joy stick move at P2.0 */
    164          #define HAL_KEY_JOY_MOVE_PORT   P2
    165          #define HAL_KEY_JOY_MOVE_BIT    BV(0)
    166          #define HAL_KEY_JOY_MOVE_SEL    P2SEL
    167          #define HAL_KEY_JOY_MOVE_DIR    P2DIR
    168          
    169          /* edge interrupt */
    170          #define HAL_KEY_JOY_MOVE_EDGEBIT  BV(3)
    171          #define HAL_KEY_JOY_MOVE_EDGE     HAL_KEY_FALLING_EDGE
    172          
    173          /* Joy move interrupts */
    174          #define HAL_KEY_JOY_MOVE_IEN      IEN2  /* CPU interrupt mask register */
    175          #define HAL_KEY_JOY_MOVE_IENBIT   BV(1) /* Mask bit for all of Port_2 */
    176          #define HAL_KEY_JOY_MOVE_ICTL     P2IEN /* Port Interrupt Control register */
    177          #define HAL_KEY_JOY_MOVE_ICTLBIT  BV(0) /* P2IENL - P2.0<->P2.3 enable/disable bit */
    178          #define HAL_KEY_JOY_MOVE_PXIFG    P2IFG /* Interrupt flag at source */
    179          
    180          #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    181          
    182          #define HAL_INTERVAL_KEY_CLOCK_THRESHOLD	900u
    183          #define HAL_LONG_KEY_TIMEOUT	4100u
    184          
    185          #define HAL_KEY_PUSH_CLOCK_SHORT_THRESHOLD	0x200
    186          #define HAL_KEY_PUSH_CLOCK_LONG_THRESHOLD	0x400
    187          
    188          #if !(defined HAL_KEY_INT_METHOD) && (defined HAL_KEY_COMBINE_INT_METHOD)
    189          #error "you must define HAL_KEY_INT_METHOD before define HAL_KEY_COMBINE_INT_METHOD"
    190          #endif
    191          
    192          
    193          /**************************************************************************************************
    194           *                                            TYPEDEFS
    195           **************************************************************************************************/
    196          
    197          
    198          /**************************************************************************************************
    199           *                                        GLOBAL VARIABLES
    200           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    201          static uint16 halKeySavedKeys;     /* used to store previous key state in polling mode */
   \                     halKeySavedKeys:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    202          static halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    203          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    204          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    205          
    206          #ifdef HAL_KEY_COMBINE_INT_METHOD

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    207          static uint32 preKeyClock;		/* last time clock */
   \                     preKeyClock:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    208          static uint32 currentKeyClock;	/* current time clock */
   \                     currentKeyClock:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    209          static uint8 constantKeyCount;	
   \                     constantKeyCount:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    210          static bool countEnd;
   \                     countEnd:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    211          static uint8 KeyCount;
   \                     KeyCount:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    212          static uint16 mKeys;
   \                     mKeys:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    213          #endif
    214          
    215          #ifdef HAL_KEY_MATCH_ID
    216          #ifndef HAL_KEY_COMBINE_INT_METHOD
    217          #error must define "HAL_KEY_COMBINE_INT_METHOD" before "HAL_KEY_MATCH_ID".
    218          #endif
    219          
    220          static const char keylist[] = {'a', '1', '2','3','4','5','6','7','8'};

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    221          static uint8 keyID[HAL_KEY_MATCH_ID_SIZE];
   \                     keyID:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    222          #endif
    223          
    224          #ifdef HAL_KEY_LONG_SHORT_DISTINGUISH
    225          static uint8 keysPush[HAL_KEY_MATCH_ID_SIZE];
    226          static uint8 isCombine;
    227          #endif
    228          
    229          #if defined(HAL_KEY_LONG_SHORT_DISTINGUISH) && !defined(HAL_KEY_INT_METHOD)
    230          #error must define "HAL_KEY_INT_METHOD" before "HAL_KEY_LONG_SHORT_DISTINGUISH".
    231          #endif
    232          
    233          /**************************************************************************************************
    234           *                                        FUNCTIONS - Local
    235           **************************************************************************************************/
    236          void halProcessKeyInterrupt(void);
    237          uint8 halGetJoyKeyInput(void);
    238          #ifdef HAL_KEY_MATCH_ID
    239          extern void set_keys_id(uint16 keys);
    240          #endif
    241          #ifdef HAL_KEY_LONG_SHORT_DISTINGUISH
    242          extern void set_keys_push(uint8 keyPush);
    243          #endif
    244          
    245          
    246          /**************************************************************************************************
    247           *                                        FUNCTIONS - API
    248           **************************************************************************************************/
    249          
    250          
    251          /**************************************************************************************************
    252           * @fn      HalKeyInit
    253           *
    254           * @brief   Initilize Key Service
    255           *
    256           * @param   none
    257           *
    258           * @return  None
    259           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    260          void HalKeyInit( void )
   \                     HalKeyInit:
    261          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    262            /* Initialize previous key to 0 */
    263            halKeySavedKeys = 0;
   \   000004   90....       MOV     DPTR,#halKeySavedKeys
   \   000007   E4           CLR     A
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   F0           MOVX    @DPTR,A
    264          
    265            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
   \   00000B   53F3DF       ANL     0xf3,#0xdf
    266            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
   \   00000E   53FDDF       ANL     0xfd,#0xdf
    267          
    268            /* No KEY JOY */
    269          #ifndef KEY_PUSH_PORT_0_BUTTON
    270            HAL_KEY_JOY_MOVE_SEL &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin function to GPIO */
    271            HAL_KEY_JOY_MOVE_DIR &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin direction to Input */
    272          #endif
    273          
    274          #ifdef KEY_PUSH_PORT_1_BUTTON
    275            HAL_KEY_PORT_1_SEL &= ~(HAL_KEY_PORT_1_BITS);
    276            HAL_KEY_PORT_1_DIR &= ~(HAL_KEY_PORT_1_BITS);
    277          #endif
    278          
    279          #ifdef HAL_KEY_COMBINE_INT_METHOD
    280          	preKeyClock = 0;
   \   000011   90....       MOV     DPTR,#__Constant_0
   \   000014   12....       LCALL   ?XLOAD_R2345
   \   000017   90....       MOV     DPTR,#preKeyClock
   \   00001A   12....       LCALL   ?XSTORE_R2345
    281          	currentKeyClock = 0;
   \   00001D   90....       MOV     DPTR,#__Constant_0
   \   000020   12....       LCALL   ?XLOAD_R2345
   \   000023   90....       MOV     DPTR,#currentKeyClock
   \   000026   12....       LCALL   ?XSTORE_R2345
    282          	constantKeyCount = 0;
   \   000029   90....       MOV     DPTR,#constantKeyCount
   \   00002C   E4           CLR     A
   \   00002D   F0           MOVX    @DPTR,A
    283          	countEnd = FALSE;
   \   00002E   90....       MOV     DPTR,#countEnd
   \   000031   F0           MOVX    @DPTR,A
    284          	KeyCount = 0;
   \   000032   90....       MOV     DPTR,#KeyCount
   \   000035   F0           MOVX    @DPTR,A
    285          #endif
    286          
    287            /* Initialize callback function */
    288            pHalKeyProcessFunction  = NULL;
   \   000036   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   F0           MOVX    @DPTR,A
    289          
    290            /* Start with key is not configured */
    291            HalKeyConfigured = FALSE;
   \   00003C   90....       MOV     DPTR,#HalKeyConfigured
   \   00003F   02....       LJMP    ?Subroutine0 & 0xFFFF
   \   000042                REQUIRE P0SEL
   \   000042                REQUIRE P0DIR
    292          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                REQUIRE ??Subroutine11_0
   \   000001                ; // Fall through to label ??Subroutine11_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine11_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    293          
    294          
    295          /**************************************************************************************************
    296           * @fn      HalKeyConfig
    297           *
    298           * @brief   Configure the Key serivce
    299           *
    300           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    301           *          cback - pointer to the CallBack function
    302           *
    303           * @return  None
    304           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    305          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    306          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    307            /* Enable/Disable Interrupt or */
    308            Hal_KeyIntEnable = interruptEnable;
   \   000006   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000009   F0           MOVX    @DPTR,A
    309          
    310            /* Register the callback fucntion */
    311            pHalKeyProcessFunction = cback;
   \   00000A   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00000D   EA           MOV     A,R2
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   EB           MOV     A,R3
   \   000011   F0           MOVX    @DPTR,A
    312          
    313            /* Determine if interrupt is enable or not */
    314            if (Hal_KeyIntEnable)
   \   000012   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000015   E0           MOVX    A,@DPTR
   \   000016   601D         JZ      ??HalKeyConfig_0
    315            {
    316              /* Rising/Falling edge configuratinn */
    317          
    318          #ifndef HAL_KEY_LONG_SHORT_DISTINGUISH
    319              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);    /* Clear the edge bit */
   \   000018   538CFE       ANL     0x8c,#0xfe
    320              /* For falling edge, the bit must be set. */
    321            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)
    322              PICTL |= HAL_KEY_SW_6_EDGEBIT;
   \   00001B   438C01       ORL     0x8c,#0x1
    323            #endif
    324          #else
    325              HalKeyEdgeChanged(0);
    326          #endif
    327          
    328          
    329              /* Interrupt configuration:
    330               * - Enable interrupt generation at the port
    331               * - Enable CPU interrupt
    332               * - Clear any pending interrupt
    333               */
    334              HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;
   \   00001E   43AB20       ORL     0xab,#0x20
    335              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;
   \   000021   D2BD         SETB    0xb8.5
    336              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);
   \   000023   7589DF       MOV     0x89,#-0x21
    337          
    338          #ifdef KEY_PUSH_PORT_1_BUTTON
    339          #ifndef HAL_KEY_LONG_SHORT_DISTINGUISH
    340          	PICTL &= ~0x06;
    341          	PICTL |= 0x06;
    342          #else
    343              HalKeyEdgeChanged(1);
    344          #endif
    345          
    346          	HAL_KEY_PORT_1_ICTL |= HAL_KEY_PORT_1_ICTLBITS;
    347              HAL_KEY_PORT_1_IEN |= HAL_KEY_PORT_1_IENBITS;
    348              HAL_KEY_PORT_1_PXIFG = ~(HAL_KEY_PORT_1_BITS);
    349          #endif
    350          
    351          #ifndef KEY_PUSH_PORT_0_BUTTON
    352              /* Rising/Falling edge configuratinn */
    353          
    354              HAL_KEY_JOY_MOVE_ICTL &= ~(HAL_KEY_JOY_MOVE_EDGEBIT);    /* Clear the edge bit */
    355              /* For falling edge, the bit must be set. */
    356            #if (HAL_KEY_JOY_MOVE_EDGE == HAL_KEY_FALLING_EDGE)
    357              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_EDGEBIT;
    358            #endif
    359          
    360          
    361              /* Interrupt configuration:
    362               * - Enable interrupt generation at the port
    363               * - Enable CPU interrupt
    364               * - Clear any pending interrupt
    365               */
    366              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_ICTLBIT;
    367              HAL_KEY_JOY_MOVE_IEN |= HAL_KEY_JOY_MOVE_IENBIT;
    368              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT);
    369          #endif
    370          
    371              /* Do this only after the hal_key is configured - to work with sleep stuff */
    372              if (HalKeyConfigured == TRUE)
   \   000026   90....       MOV     DPTR,#HalKeyConfigured
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6401         XRL     A,#0x1
   \   00002C   7018         JNZ     ??HalKeyConfig_1
    373              {
    374                osal_stop_timerEx(Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
   \   00002E                ; Setup parameters for call to function osal_stop_timerEx
   \   00002E   7A01         MOV     R2,#0x1
   \   000030   12....       LCALL   ?Subroutine5 & 0xFFFF
    375              }
    376            }
   \                     ??CrossCallReturnLabel_11:
   \   000033   8011         SJMP    ??HalKeyConfig_1
    377            else    /* Interrupts NOT enabled */
    378            {
    379              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT); /* don't generate interrupt */
   \                     ??HalKeyConfig_0:
   \   000035   53ABDF       ANL     0xab,#0xdf
    380              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);   /* Clear interrupt enable bit */
   \   000038   C2BD         CLR     0xb8.5
    381          
    382          #ifdef KEY_PUSH_PORT_1_BUTTON
    383          	HAL_KEY_PORT_1_ICTL &= ~(HAL_KEY_PORT_1_ICTLBITS);
    384              HAL_KEY_PORT_1_IEN &= ~(HAL_KEY_PORT_1_IENBITS);
    385          #endif
    386          
    387              osal_set_event(Hal_TaskID, HAL_KEY_EVENT);
   \   00003A                ; Setup parameters for call to function osal_set_event
   \   00003A   7A01         MOV     R2,#0x1
   \   00003C   7B00         MOV     R3,#0x0
   \   00003E   90....       MOV     DPTR,#Hal_TaskID
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F9           MOV     R1,A
   \   000043   12....       LCALL   ??osal_set_event?relay
    388            }
    389          
    390            /* Key now is configured */
    391            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_1:
   \   000046   90....       MOV     DPTR,#HalKeyConfigured
   \   000049   7401         MOV     A,#0x1
   \   00004B   F0           MOVX    @DPTR,A
    392          }
   \   00004C   FF           MOV     R7,A
   \   00004D   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000050                REQUIRE PICTL
   \   000050                REQUIRE P0IEN
   \   000050                REQUIRE _A_IEN1
   \   000050                REQUIRE P0IFG

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7B00         MOV     R3,#0x0
   \   000002                REQUIRE ??Subroutine7_0
   \   000002                ; // Fall through to label ??Subroutine7_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine7_0:
   \   000000   90....       MOV     DPTR,#Hal_TaskID
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   12....       LCALL   ??osal_stop_timerEx?relay
   \   000008   22           RET
    393          
    394          /**************************************************************************************************
    395           * @fn      HalKeyRead
    396           *
    397           * @brief   Read the current value of a key
    398           *
    399           * @param   None
    400           *
    401           * @return  keys - current keys status
    402           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    403          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    404          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    405            uint16 keys = 0;
   \   000000   7800         MOV     R0,#0x0
    406          
    407            if (HAL_PUSH_BUTTON1())
   \   000002   A285         MOV     C,0x80.5
   \   000004   4002         JC      ??HalKeyRead_0
    408            {
    409              keys |= HAL_KEY_SW_6;
   \   000006   7820         MOV     R0,#0x20
    410            }
    411          
    412          #ifdef KEY_PUSH_PORT_1_BUTTON
    413            keys |= (HAL_KEY_PUSH_PORT_1_BUTTON() << 8);
    414          #endif
    415          
    416          #ifndef KEY_PUSH_PORT_0_BUTTON
    417            if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active low */
    418            {
    419              keys |= halGetJoyKeyInput();
    420            }
    421          #endif
    422          
    423            return keys;
   \                     ??HalKeyRead_0:
   \   000008   E8           MOV     A,R0
   \   000009   F9           MOV     R1,A
   \   00000A   02....       LJMP    ?BRET
   \   00000D                REQUIRE _A_P0
    424          }
    425          
    426          
    427          /**************************************************************************************************
    428           * @fn      HalKeyPoll
    429           *
    430           * @brief   Called by hal_driver to poll the keys
    431           *
    432           * @param   None
    433           *
    434           * @return  None
    435           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    436          void HalKeyPoll (void)
   \                     HalKeyPoll:
    437          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    438            uint16 keys = 0;
   \   000005   7E00         MOV     R6,#0x0
    439          #ifdef HAL_KEY_LONG_SHORT_DISTINGUISH
    440            uint8 mKeyPush = 0;
    441          #ifdef KEY_PUSH_PORT_1_BUTTON
    442            static uint16 tKeys = 0;
    443          #endif
    444          #endif
    445          
    446          #ifndef KEY_PUSH_PORT_0_BUTTON
    447            if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active HIGH */
    448            {
    449              keys = halGetJoyKeyInput();
    450            }
    451          #endif
    452          
    453          #ifndef HAL_KEY_LONG_SHORT_DISTINGUISH
    454            if (HAL_PUSH_BUTTON1())
   \   000007   A285         MOV     C,0x80.5
   \   000009   4002         JC      ??HalKeyPoll_0
    455            {
    456              keys |= HAL_KEY_SW_6;
   \   00000B   7E20         MOV     R6,#0x20
    457            }
    458          #else
    459            if (HalKeyGetEdge(0) ^ PUSH1_SBIT)
    460            {
    461              uint16 pushclock = (uint16)HalKeyEdgeChanged(0);
    462              if(pushclock != 0)
    463              {
    464          	  if (pushclock < HAL_KEY_PUSH_CLOCK_SHORT_THRESHOLD)
    465          	  {
    466          		mKeyPush = HAL_KEY_SHORT_PUSH;
    467          	  }
    468          	  else if (pushclock > HAL_KEY_PUSH_CLOCK_LONG_THRESHOLD)
    469          	  {
    470          		mKeyPush = HAL_KEY_LONG_PUSH;
    471          	  }
    472          
    473          	  keys |= HAL_KEY_SW_6;
    474              }
    475            }
    476          #endif
    477          
    478          #ifdef KEY_PUSH_PORT_1_BUTTON
    479          #ifndef HAL_KEY_LONG_SHORT_DISTINGUISH
    480            keys |= (HAL_KEY_PUSH_PORT_1_BUTTON() << 8);
    481          #else
    482          
    483            if ((!!HalKeyGetEdge(1)) ^ (!HAL_KEY_PUSH_PORT_1_BUTTON()))
    484            {
    485          
    486              uint16 pushclock = (uint16)HalKeyEdgeChanged(1);
    487          	
    488              if(pushclock != 0)
    489              {
    490          	  if (pushclock < HAL_KEY_PUSH_CLOCK_SHORT_THRESHOLD)
    491          	  {
    492          		mKeyPush = HAL_KEY_SHORT_PUSH;
    493          	  }
    494          	  else if (pushclock > HAL_KEY_PUSH_CLOCK_LONG_THRESHOLD)
    495          	  {
    496          		mKeyPush = HAL_KEY_LONG_PUSH;
    497          	  }
    498          
    499          	  keys |= tKeys;
    500              }
    501          	else
    502          	{
    503          	  tKeys = (HAL_KEY_PUSH_PORT_1_BUTTON() << 8);
    504          	}
    505            }
    506          #endif
    507          #endif
    508          
    509          
    510            /* If interrupts are not enabled, previous key status and current key status
    511             * are compared to find out if a key has changed status.
    512             */
    513            if (!Hal_KeyIntEnable)
   \                     ??HalKeyPoll_0:
   \   00000D   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000010   E0           MOVX    A,@DPTR
   \   000011   702E         JNZ     ??HalKeyPoll_1
    514            {
    515              if (keys == halKeySavedKeys)
   \   000013   90....       MOV     DPTR,#halKeySavedKeys
   \   000016   E0           MOVX    A,@DPTR
   \   000017   6E           XRL     A,R6
   \   000018   7002         JNZ     ??HalKeyPoll_2
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \                     ??HalKeyPoll_2:
   \   00001C   601E         JZ      ??HalKeyPoll_3
    516              {
    517                /* Exit - since no keys have changed */
    518                return;
    519              }
    520              /* Store the current keys for comparation next time */
    521              halKeySavedKeys = keys;
   \   00001E   90....       MOV     DPTR,#halKeySavedKeys
   \   000021   EE           MOV     A,R6
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E4           CLR     A
   \   000025   F0           MOVX    @DPTR,A
    522            }
    523            else
    524            {
    525          #ifdef HAL_KEY_COMBINE_INT_METHOD
    526          	if (!keys) return;
    527          
    528          	if (!constantKeyCount)
    529          	{
    530          		preKeyClock = osal_GetSystemClock();
    531          #ifdef HAL_KEY_LONG_SHORT_DISTINGUISH
    532          		isCombine = 1;
    533          #ifdef KEY_PUSH_PORT_1_BUTTON
    534          		tKeys = 0;
    535          #endif
    536          #endif
    537          	}
    538          	
    539          	currentKeyClock = osal_GetSystemClock();
    540          	countEnd = FALSE;
    541          	osal_stop_timerEx(Hal_TaskID, HAL_KEY_COUNT_EVENT);
    542          	osal_stop_timerEx( Hal_TaskID, HAL_LONG_KEY_EVENT);
    543          
    544          	if (currentKeyClock - preKeyClock < HAL_INTERVAL_KEY_CLOCK_THRESHOLD)
    545          	{
    546          		constantKeyCount++;
    547          		preKeyClock = currentKeyClock;
    548          		
    549          		mKeys = keys;
    550          #ifdef HAL_KEY_MATCH_ID
    551          		set_keys_id(keys);
    552          #endif
    553          #ifdef HAL_KEY_LONG_SHORT_DISTINGUISH
    554          		if(constantKeyCount == 1 && mKeyPush == HAL_KEY_SHORT_PUSH)
    555          		{
    556          			isCombine = 0;
    557          			memset(keyID, 0, sizeof(keyID));
    558          			memset(keysPush, 0, sizeof(keysPush));
    559          		}
    560          
    561          		set_keys_push(mKeyPush);
    562          		
    563          		if(!isCombine)
    564          		{
    565          			KeyCount = constantKeyCount;
    566          			constantKeyCount = 0;
    567          			goto functionSolve;
    568          		}
    569          #endif
    570          
    571          		osal_start_timerEx( Hal_TaskID, 
    572          			HAL_KEY_COUNT_EVENT, HAL_INTERVAL_KEY_CLOCK_THRESHOLD);
    573          
    574          		return;
    575          	}
    576          	else
    577          	{
    578          		KeyCount = constantKeyCount;
    579          		constantKeyCount = 0;
    580          		return;
    581          	}
    582          #endif
    583            }
    584          
    585          #ifdef HAL_KEY_LONG_SHORT_DISTINGUISH
    586          functionSolve:
    587          #endif
    588            /* Invoke Callback if new keys were depressed */
    589            if (keys && (pHalKeyProcessFunction))
   \   000026   EE           MOV     A,R6
   \   000027   6013         JZ      ??HalKeyPoll_3
   \   000029   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00002C   600E         JZ      ??HalKeyPoll_3
    590            {
    591              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
   \   00002E                ; Setup parameters for indirect call
   \   00002E   7900         MOV     R1,#0x0
   \   000030   EE           MOV     A,R6
   \   000031   FA           MOV     R2,A
   \   000032   7B00         MOV     R3,#0x0
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F583         MOV     DPH,A
   \   000037   8882         MOV     DPL,R0
   \   000039   12....       LCALL   ?CALL_IND
   \                     ??HalKeyPoll_3:
   \   00003C   7F04         MOV     R7,#0x4
   \   00003E   02....       LJMP    ?BANKED_LEAVE_XDATA
    592            }
   \                     ??HalKeyPoll_1:
   \   000041   EE           MOV     A,R6
   \   000042   60F8         JZ      ??HalKeyPoll_3
   \   000044   90....       MOV     DPTR,#constantKeyCount
   \   000047   E0           MOVX    A,@DPTR
   \   000048   7009         JNZ     ??HalKeyPoll_4
   \   00004A                ; Setup parameters for call to function osal_GetSystemClock
   \   00004A   12....       LCALL   ??osal_GetSystemClock?relay
   \   00004D   90....       MOV     DPTR,#preKeyClock
   \   000050   12....       LCALL   ?XSTORE_R2345
   \                     ??HalKeyPoll_4:
   \   000053                ; Setup parameters for call to function osal_GetSystemClock
   \   000053   12....       LCALL   ??osal_GetSystemClock?relay
   \   000056   90....       MOV     DPTR,#currentKeyClock
   \   000059   12....       LCALL   ?XSTORE_R2345
   \   00005C   90....       MOV     DPTR,#countEnd
   \   00005F   E4           CLR     A
   \   000060   F0           MOVX    @DPTR,A
   \   000061                ; Setup parameters for call to function osal_stop_timerEx
   \   000061   7A10         MOV     R2,#0x10
   \   000063   FB           MOV     R3,A
   \   000064   12....       LCALL   ??Subroutine7_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000067                ; Setup parameters for call to function osal_stop_timerEx
   \   000067   7A20         MOV     R2,#0x20
   \   000069   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00006C   90....       MOV     DPTR,#currentKeyClock
   \   00006F   78..         MOV     R0,#?V0 + 0
   \   000071   12....       LCALL   ?L_MOV_X
   \   000074   90....       MOV     DPTR,#preKeyClock
   \   000077   78..         MOV     R0,#?V0 + 0
   \   000079   12....       LCALL   ?L_SUB_X
   \   00007C   90....       MOV     DPTR,#__Constant_384
   \   00007F   78..         MOV     R0,#?V0 + 0
   \   000081   12....       LCALL   ?UL_GE_X
   \   000084   90....       MOV     DPTR,#constantKeyCount
   \   000087   E0           MOVX    A,@DPTR
   \   000088   4028         JC      ??HalKeyPoll_5
   \   00008A   04           INC     A
   \   00008B   F0           MOVX    @DPTR,A
   \   00008C   90....       MOV     DPTR,#currentKeyClock
   \   00008F   12....       LCALL   ?XLOAD_R2345
   \   000092   90....       MOV     DPTR,#preKeyClock
   \   000095   12....       LCALL   ?XSTORE_R2345
   \   000098   90....       MOV     DPTR,#mKeys
   \   00009B   EE           MOV     A,R6
   \   00009C   F0           MOVX    @DPTR,A
   \   00009D   A3           INC     DPTR
   \   00009E   E4           CLR     A
   \   00009F   F0           MOVX    @DPTR,A
   \   0000A0                ; Setup parameters for call to function set_keys_id
   \   0000A0   EE           MOV     A,R6
   \   0000A1   FA           MOV     R2,A
   \   0000A2   7B00         MOV     R3,#0x0
   \   0000A4   12....       LCALL   ??set_keys_id?relay
   \   0000A7                ; Setup parameters for call to function osal_start_timerEx
   \   0000A7   7C84         MOV     R4,#-0x7c
   \   0000A9   7D03         MOV     R5,#0x3
   \   0000AB   7A10         MOV     R2,#0x10
   \   0000AD   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000B0   808A         SJMP    ??HalKeyPoll_3
   \                     ??HalKeyPoll_5:
   \   0000B2   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000B5   8085         SJMP    ??HalKeyPoll_3
   \   0000B7                REQUIRE _A_P0
    593          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   7B00         MOV     R3,#0x0
   \   000002                REQUIRE ??Subroutine8_0
   \   000002                ; // Fall through to label ??Subroutine8_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine8_0:
   \   000000   90....       MOV     DPTR,#Hal_TaskID
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   12....       LCALL   ??osal_start_timerEx?relay
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   90....       MOV     DPTR,#KeyCount
   \   000003                REQUIRE ??Subroutine9_0
   \   000003                ; // Fall through to label ??Subroutine9_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine9_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#constantKeyCount
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000003                REQUIRE ??Subroutine10_0
   \   000003                ; // Fall through to label ??Subroutine10_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   49           ORL     A,R1
   \   000007   22           RET
    594          
    595          #ifdef HAL_KEY_LONG_SHORT_DISTINGUISH
    596          uint8 HalKeyGetEdge(uint8 port)
    597          {
    598            if (port == 0)
    599            {
    600          	  return (PICTL & HAL_KEY_SW_6_EDGEBIT);
    601            }
    602            else if (port == 1)
    603            {
    604          	  return (PICTL & 0x06);
    605            }
    606          
    607            return 0;
    608          }
    609          
    610          
    611          uint32 HalKeyEdgeChanged(uint8 port)
    612          {
    613            static uint32 highClock, lowClock;
    614            
    615            if (port == 0)
    616            {
    617              if (PUSH1_SBIT)
    618              {
    619          	  PICTL |= HAL_KEY_SW_6_EDGEBIT;
    620          	  //HalLedSet(HAL_LED_1, HAL_LED_MODE_OFF);
    621          	  highClock = osal_GetSystemClock();
    622          	}
    623          	else
    624          	{
    625          	  PICTL &= ~HAL_KEY_SW_6_EDGEBIT;
    626          	  //HalLedSet(HAL_LED_1, HAL_LED_MODE_ON);
    627          	  lowClock = osal_GetSystemClock();
    628          	}
    629          
    630          	if(!HAL_PUSH_BUTTON1())
    631          	{
    632          	  if(PUSH1_POLARITY(0))
    633          	  {
    634          		return highClock-lowClock;
    635          	  }
    636          	  else
    637          	  {
    638          	  	return lowClock-highClock;
    639          	  }
    640          	}
    641          	else
    642          	{
    643          		return 0;
    644          	}
    645            }
    646          #ifdef KEY_PUSH_PORT_1_BUTTON
    647            else if (port == 1)
    648            {
    649          	if((!!HAL_KEY_PUSH_PORT_1_BUTTON()) ^ (PUSH_PORT_1_POLARITY(0) & 0x01))
    650              {
    651          	  PICTL |= 0x06;
    652          	  //HalLedSet(HAL_LED_1, HAL_LED_MODE_OFF);
    653          	  highClock = osal_GetSystemClock();
    654          	}
    655          	else
    656          	{
    657          	  PICTL &= ~0x06;
    658          	  //HalLedSet(HAL_LED_1, HAL_LED_MODE_ON);
    659          	  lowClock = osal_GetSystemClock();
    660          	}
    661          
    662          	if(!HAL_KEY_PUSH_PORT_1_BUTTON())
    663          	{
    664          	  if(PUSH_PORT_1_POLARITY(0) & 0x01)
    665          	  {
    666          		return highClock-lowClock;
    667          	  }
    668          	  else
    669          	  {
    670          	  	return lowClock-highClock;
    671          	  }
    672          	}
    673          	else
    674          	{
    675          		return 0;
    676          	}
    677            }
    678          #endif
    679          
    680            return 0;
    681          }
    682          #endif
    683          
    684          
    685          #ifdef HAL_KEY_COMBINE_INT_METHOD

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    686          static bool countDown = FALSE;
   \                     countDown:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    687          void HalKeyCountPoll (void)
   \                     HalKeyCountPoll:
    688          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    689            // ³¤°´ÊÂ¼þ¼ì²â
    690            if(HAL_PUSH_BUTTON1() || countDown
    691          #ifdef KEY_PUSH_PORT_1_BUTTON
    692            		|| HAL_KEY_PUSH_PORT_1_BUTTON()
    693          #endif
    694            )
   \   000004   A285         MOV     C,0x80.5
   \   000006   5006         JNC     ??HalKeyCountPoll_0
   \   000008   90....       MOV     DPTR,#countDown
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   604A         JZ      ??HalKeyCountPoll_1
    695            {	
    696          #ifndef HAL_KEY_LONG_SHORT_DISTINGUISH
    697            	if(constantKeyCount == 1)
   \                     ??HalKeyCountPoll_0:
   \   00000E   90....       MOV     DPTR,#constantKeyCount
   \   000011   E0           MOVX    A,@DPTR
   \   000012   6401         XRL     A,#0x1
   \   000014   7018         JNZ     ??HalKeyCountPoll_2
    698            	{
    699          	  countDown = FALSE;
   \   000016   90....       MOV     DPTR,#countDown
   \   000019   E4           CLR     A
   \   00001A   F0           MOVX    @DPTR,A
    700          	  KeyCount = constantKeyCount;
   \   00001B   90....       MOV     DPTR,#KeyCount
   \   00001E   04           INC     A
   \   00001F   12....       LCALL   ??Subroutine9_0 & 0xFFFF
    701            	  constantKeyCount = 0;
    702          	  osal_start_timerEx( Hal_TaskID, 
    703          			HAL_LONG_KEY_EVENT, HAL_LONG_KEY_TIMEOUT);
   \                     ??CrossCallReturnLabel_19:
   \   000022                ; Setup parameters for call to function osal_start_timerEx
   \   000022   7C04         MOV     R4,#0x4
   \   000024   7D10         MOV     R5,#0x10
   \   000026   7A20         MOV     R2,#0x20
   \   000028   FB           MOV     R3,A
   \                     ??HalKeyCountPoll_3:
   \   000029   12....       LCALL   ??Subroutine8_0 & 0xFFFF
    704          	  return;
   \                     ??CrossCallReturnLabel_16:
   \   00002C   805B         SJMP    ??HalKeyCountPoll_4
    705          	}
    706          #endif
    707          
    708            	preKeyClock = osal_GetSystemClock();
   \                     ??HalKeyCountPoll_2:
   \   00002E                ; Setup parameters for call to function osal_GetSystemClock
   \   00002E   12....       LCALL   ??osal_GetSystemClock?relay
   \   000031   90....       MOV     DPTR,#preKeyClock
   \   000034   12....       LCALL   ?XSTORE_R2345
    709          	
    710            	if(HAL_PUSH_BUTTON1()
    711          #ifdef KEY_PUSH_PORT_1_BUTTON
    712            		|| HAL_KEY_PUSH_PORT_1_BUTTON()
    713          #endif
    714          	)
   \   000037   A285         MOV     C,0x80.5
   \   000039   90....       MOV     DPTR,#countDown
   \   00003C   400D         JC      ??HalKeyCountPoll_5
    715            	{
    716          	  countDown = TRUE;
   \   00003E   7401         MOV     A,#0x1
   \   000040   F0           MOVX    @DPTR,A
    717            	}
    718          	else
    719          	{
    720          	  countDown = FALSE;
    721          	  countEnd = TRUE;
    722          	  osal_start_timerEx( Hal_TaskID, 
    723          			HAL_KEY_COUNT_EVENT, HAL_INTERVAL_KEY_CLOCK_THRESHOLD);
    724          	  return;
    725          	}
    726          
    727          	osal_start_timerEx( Hal_TaskID, HAL_KEY_COUNT_EVENT, 25);
   \   000041                ; Setup parameters for call to function osal_start_timerEx
   \   000041   7C19         MOV     R4,#0x19
   \   000043   7D00         MOV     R5,#0x0
   \                     ??HalKeyCountPoll_6:
   \   000045   7A10         MOV     R2,#0x10
   \   000047   7B00         MOV     R3,#0x0
   \   000049   80DE         SJMP    ??HalKeyCountPoll_3
   \                     ??HalKeyCountPoll_5:
   \   00004B   E4           CLR     A
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   90....       MOV     DPTR,#countEnd
   \   000050   04           INC     A
   \   000051   F0           MOVX    @DPTR,A
   \   000052                ; Setup parameters for call to function osal_start_timerEx
   \   000052   7C84         MOV     R4,#-0x7c
   \   000054   7D03         MOV     R5,#0x3
   \   000056   80ED         SJMP    ??HalKeyCountPoll_6
    728          	return;
    729            }
    730            else if(countEnd)
   \                     ??HalKeyCountPoll_1:
   \   000058   90....       MOV     DPTR,#countEnd
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   600F         JZ      ??HalKeyCountPoll_7
    731            {
    732            	KeyCount = 0;
   \   00005E   90....       MOV     DPTR,#KeyCount
   \   000061   E4           CLR     A
   \   000062   F0           MOVX    @DPTR,A
    733              constantKeyCount = 0;
   \   000063   90....       MOV     DPTR,#constantKeyCount
   \   000066   F0           MOVX    @DPTR,A
    734            	countEnd = FALSE;
   \   000067   90....       MOV     DPTR,#countEnd
   \   00006A   F0           MOVX    @DPTR,A
    735          #ifndef HAL_KEY_LONG_SHORT_DISTINGUISH
    736          	return;
   \   00006B   801C         SJMP    ??HalKeyCountPoll_4
    737          #endif
    738            }
    739          
    740            //×éºÏ°´¼üÊÂ¼þ´¦Àí
    741            KeyCount = constantKeyCount;
   \                     ??HalKeyCountPoll_7:
   \   00006D   90....       MOV     DPTR,#constantKeyCount
   \   000070   E0           MOVX    A,@DPTR
   \   000071   12....       LCALL   ?Subroutine4 & 0xFFFF
    742            constantKeyCount = 0;
    743            if (mKeys&& (pHalKeyProcessFunction))
   \                     ??CrossCallReturnLabel_18:
   \   000074   90....       MOV     DPTR,#mKeys
   \   000077   12....       LCALL   ??Subroutine10_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   00007A   600D         JZ      ??HalKeyCountPoll_4
   \   00007C   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00007F   6008         JZ      ??HalKeyCountPoll_4
    744            {
    745              (pHalKeyProcessFunction) (mKeys, HAL_KEY_STATE_NORMAL);
   \   000081                ; Setup parameters for indirect call
   \   000081   7900         MOV     R1,#0x0
   \   000083   12....       LCALL   ?Subroutine3 & 0xFFFF
    746            }
   \                     ??CrossCallReturnLabel_9:
   \   000086   12....       LCALL   ?CALL_IND
   \                     ??HalKeyCountPoll_4:
   \   000089   80..         SJMP    ??Subroutine11_0
   \   00008B                REQUIRE _A_P0
    747          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   90....       MOV     DPTR,#mKeys
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FB           MOV     R3,A
   \   000008   90....       MOV     DPTR,#pHalKeyProcessFunction + 1
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F583         MOV     DPH,A
   \   00000E   8882         MOV     DPL,R0
   \   000010   22           RET
    748          
    749          #ifndef HAL_KEY_LONG_SHORT_DISTINGUISH

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    750          void HalLongKeyListener(void)
   \                     HalLongKeyListener:
    751          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    752          	if((HAL_PUSH_BUTTON1() 
    753          #ifdef KEY_PUSH_PORT_1_BUTTON
    754            		|| HAL_KEY_PUSH_PORT_1_BUTTON()
    755          #endif
    756          		)&& KeyCount == 1)
   \   000004   A285         MOV     C,0x80.5
   \   000006   4021         JC      ??HalLongKeyListener_0
   \   000008   90....       MOV     DPTR,#KeyCount
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   6401         XRL     A,#0x1
   \   00000E   7019         JNZ     ??HalLongKeyListener_0
    757            	{
    758          		if (mKeys && (pHalKeyProcessFunction))
   \   000010   90....       MOV     DPTR,#mKeys
   \   000013   12....       LCALL   ??Subroutine10_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000016   6011         JZ      ??HalLongKeyListener_0
   \   000018   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00001B   600C         JZ      ??HalLongKeyListener_0
    759          	  	{
    760          			KeyCount = 0;
   \   00001D   90....       MOV     DPTR,#KeyCount
   \   000020   E4           CLR     A
   \   000021   F0           MOVX    @DPTR,A
    761              		(pHalKeyProcessFunction) (mKeys, HAL_KEY_STATE_NORMAL);
   \   000022                ; Setup parameters for indirect call
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   ?Subroutine3 & 0xFFFF
    762            		}
    763          	}
   \                     ??CrossCallReturnLabel_10:
   \   000026   12....       LCALL   ?CALL_IND
    764          }
   \                     ??HalLongKeyListener_0:
   \   000029   80..         SJMP    ??Subroutine11_0
   \   00002B                REQUIRE _A_P0
    765          #endif
    766          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    767          uint8 halGetKeyCount(void)
   \                     halGetKeyCount:
    768          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    769          	uint8 mCount = KeyCount;
   \   000004   90....       MOV     DPTR,#KeyCount
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
    770          	KeyCount = 0;
   \   000009   E4           CLR     A
   \   00000A   80..         SJMP    ?Subroutine0
    771          	
    772          	return mCount;
    773          }
    774          
    775          
    776          #ifdef HAL_KEY_MATCH_ID

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    777          void set_keys_id(uint16 keys)
   \                     set_keys_id:
    778          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    779          	switch(keys)
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for set_keys_id>_0`:
   \   00000E   0000         DW        0
   \   000010   0900         DW        9
   \   000012   2000         DW        32
   \   000014   ....         DW        ??set_keys_id_0
   \   000016   0001         DW        256
   \   000018   ....         DW        ??set_keys_id_1
   \   00001A   0002         DW        512
   \   00001C   ....         DW        ??set_keys_id_2
   \   00001E   0004         DW        1024
   \   000020   ....         DW        ??set_keys_id_3
   \   000022   0008         DW        2048
   \   000024   ....         DW        ??set_keys_id_4
   \   000026   0010         DW        4096
   \   000028   ....         DW        ??set_keys_id_5
   \   00002A   0020         DW        8192
   \   00002C   ....         DW        ??set_keys_id_6
   \   00002E   0040         DW        16384
   \   000030   ....         DW        ??set_keys_id_7
   \   000032   0080         DW        32768
   \   000034   ....         DW        ??set_keys_id_8
   \   000036   ....         DW        ??set_keys_id_9
    780          	{
    781          	case HAL_KEY_SW_6: 
    782          		keyID[constantKeyCount-1] = keylist[0];
   \                     ??set_keys_id_0:
   \   000038   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00003B   7461         MOV     A,#0x61
   \   00003D   8036         SJMP    ??set_keys_id_10
    783          		break;
    784          		
    785          	case HAL_KEY_PORT_1_SWITCH_1: 
    786          		keyID[constantKeyCount-1] = keylist[1];
   \                     ??set_keys_id_1:
   \   00003F   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000042   7431         MOV     A,#0x31
   \   000044   802F         SJMP    ??set_keys_id_10
    787          		break;
    788          		
    789          	case HAL_KEY_PORT_1_SWITCH_2: 
    790          		keyID[constantKeyCount-1] = keylist[2];
   \                     ??set_keys_id_2:
   \   000046   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000049   7432         MOV     A,#0x32
   \   00004B   8028         SJMP    ??set_keys_id_10
    791          		break;
    792          		
    793          	case HAL_KEY_PORT_1_SWITCH_3: 
    794          		keyID[constantKeyCount-1] = keylist[3];
   \                     ??set_keys_id_3:
   \   00004D   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000050   7433         MOV     A,#0x33
   \   000052   8021         SJMP    ??set_keys_id_10
    795          		break;
    796          		
    797          	case HAL_KEY_PORT_1_SWITCH_4: 
    798          		keyID[constantKeyCount-1] = keylist[4];
   \                     ??set_keys_id_4:
   \   000054   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000057   7434         MOV     A,#0x34
   \   000059   801A         SJMP    ??set_keys_id_10
    799          		break;
    800          		
    801          	case HAL_KEY_PORT_1_SWITCH_5: 
    802          		keyID[constantKeyCount-1] = keylist[5];
   \                     ??set_keys_id_5:
   \   00005B   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00005E   7435         MOV     A,#0x35
   \   000060   8013         SJMP    ??set_keys_id_10
    803          		break;
    804          		
    805          	case HAL_KEY_PORT_1_SWITCH_6: 
    806          		keyID[constantKeyCount-1] = keylist[6];
   \                     ??set_keys_id_6:
   \   000062   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000065   7436         MOV     A,#0x36
   \   000067   800C         SJMP    ??set_keys_id_10
    807          		break;
    808          		
    809          	case HAL_KEY_PORT_1_SWITCH_7: 
    810          		keyID[constantKeyCount-1] = keylist[7];
   \                     ??set_keys_id_7:
   \   000069   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00006C   7437         MOV     A,#0x37
   \   00006E   8005         SJMP    ??set_keys_id_10
    811          		break;
    812          		
    813          	case HAL_KEY_PORT_1_SWITCH_8: 
    814          		keyID[constantKeyCount-1] = keylist[8];
   \                     ??set_keys_id_8:
   \   000070   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000073   7438         MOV     A,#0x38
   \                     ??set_keys_id_10:
   \   000075   F0           MOVX    @DPTR,A
    815          		break;
    816          		
    817          	default: break;
    818          	}
    819          
    820          }
   \                     ??set_keys_id_9:
   \   000076   7F02         MOV     R7,#0x2
   \   000078   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   90....       MOV     DPTR,#constantKeyCount
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   74..         MOV     A,#(keyID + 255) & 0xff
   \   000007   28           ADD     A,R0
   \   000008   F582         MOV     DPL,A
   \   00000A   74..         MOV     A,#((keyID - 1) >> 8) & 0xff
   \   00000C   3400         ADDC    A,#0x0
   \   00000E   F583         MOV     DPH,A
   \   000010   22           RET
    821          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    822          uint8 *get_keys_id(void)
   \                     get_keys_id:
    823          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    824          	return keyID;
   \   000000   7A..         MOV     R2,#keyID & 0xff
   \   000002   7B..         MOV     R3,#(keyID >> 8) & 0xff
   \   000004   02....       LJMP    ?BRET
    825          }
    826          #endif
    827          
    828          #ifdef HAL_KEY_LONG_SHORT_DISTINGUISH
    829          void set_keys_push(uint8 keyPush)
    830          {
    831          	keysPush[constantKeyCount-1] = keyPush;
    832          }
    833          
    834          uint8 *get_keys_push(void)
    835          {
    836          	return keysPush;
    837          }
    838          #endif
    839          
    840          #else
    841          uint8 halGetKeyCount(void)
    842          {	
    843          	return 0;
    844          }
    845          #endif
    846          
    847          /**************************************************************************************************
    848           * @fn      halGetJoyKeyInput
    849           *
    850           * @brief   Map the ADC value to its corresponding key.
    851           *
    852           * @param   None
    853           *
    854           * @return  keys - current joy key status
    855           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    856          uint8 halGetJoyKeyInput(void)
   \                     halGetJoyKeyInput:
    857          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    858            /* The joystick control is encoded as an analog voltage.
    859             * Read the JOY_LEVEL analog value and map it to joy movement.
    860             */
    861            uint8 adc;
    862            uint8 ksave0 = 0;
   \   000005   7E00         MOV     R6,#0x0
    863            uint8 ksave1;
    864          
    865            /* Keep on reading the ADC until two consecutive key decisions are the same. */
    866            do
    867            {
    868              ksave1 = ksave0;    /* save previouse key reading */
   \                     ??halGetJoyKeyInput_0:
   \   000007   EE           MOV     A,R6
   \   000008   FF           MOV     R7,A
    869          
    870              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
   \   000009                ; Setup parameters for call to function HalAdcRead
   \   000009   7A01         MOV     R2,#0x1
   \   00000B   7906         MOV     R1,#0x6
   \   00000D   12....       LCALL   ??HalAdcRead?relay
   \   000010   EA           MOV     A,R2
   \   000011   F8           MOV     R0,A
    871          
    872              if ((adc >= 2) && (adc <= 38))
   \   000012   74FE         MOV     A,#-0x2
   \   000014   28           ADD     A,R0
   \   000015   C3           CLR     C
   \   000016   9425         SUBB    A,#0x25
   \   000018   5005         JNC     ??halGetJoyKeyInput_1
    873              {
    874                 ksave0 |= HAL_KEY_UP;
   \   00001A   EE           MOV     A,R6
   \   00001B   D2E0         SETB    0xE0 /* A   */.0
   \   00001D   8032         SJMP    ??halGetJoyKeyInput_2
    875              }
    876              else if ((adc >= 74) && (adc <= 88))
   \                     ??halGetJoyKeyInput_1:
   \   00001F   74B6         MOV     A,#-0x4a
   \   000021   28           ADD     A,R0
   \   000022   C3           CLR     C
   \   000023   940F         SUBB    A,#0xf
   \   000025   5005         JNC     ??halGetJoyKeyInput_3
    877              {
    878                ksave0 |= HAL_KEY_RIGHT;
   \   000027   EE           MOV     A,R6
   \   000028   D2E1         SETB    0xE0 /* A   */.1
   \   00002A   8025         SJMP    ??halGetJoyKeyInput_2
    879              }
    880              else if ((adc >= 60) && (adc <= 73))
   \                     ??halGetJoyKeyInput_3:
   \   00002C   74C4         MOV     A,#-0x3c
   \   00002E   28           ADD     A,R0
   \   00002F   C3           CLR     C
   \   000030   940E         SUBB    A,#0xe
   \   000032   5005         JNC     ??halGetJoyKeyInput_4
    881              {
    882                ksave0 |= HAL_KEY_LEFT;
   \   000034   EE           MOV     A,R6
   \   000035   D2E3         SETB    0xE0 /* A   */.3
   \   000037   8018         SJMP    ??halGetJoyKeyInput_2
    883              }
    884              else if ((adc >= 39) && (adc <= 59))
   \                     ??halGetJoyKeyInput_4:
   \   000039   74D9         MOV     A,#-0x27
   \   00003B   28           ADD     A,R0
   \   00003C   C3           CLR     C
   \   00003D   9415         SUBB    A,#0x15
   \   00003F   5005         JNC     ??halGetJoyKeyInput_5
    885              {
    886                ksave0 |= HAL_KEY_DOWN;
   \   000041   EE           MOV     A,R6
   \   000042   D2E4         SETB    0xE0 /* A   */.4
   \   000044   800B         SJMP    ??halGetJoyKeyInput_2
    887              }
    888              else if ((adc >= 89) && (adc <= 100))
   \                     ??halGetJoyKeyInput_5:
   \   000046   74A7         MOV     A,#-0x59
   \   000048   28           ADD     A,R0
   \   000049   C3           CLR     C
   \   00004A   940C         SUBB    A,#0xc
   \   00004C   5004         JNC     ??halGetJoyKeyInput_6
    889              {
    890                ksave0 |= HAL_KEY_CENTER;
   \   00004E   EE           MOV     A,R6
   \   00004F   D2E2         SETB    0xE0 /* A   */.2
   \                     ??halGetJoyKeyInput_2:
   \   000051   FE           MOV     R6,A
    891              }
    892            } while (ksave0 != ksave1);
   \                     ??halGetJoyKeyInput_6:
   \   000052   EF           MOV     A,R7
   \   000053   6E           XRL     A,R6
   \   000054   70B1         JNZ     ??halGetJoyKeyInput_0
    893          
    894            return ksave0;
   \   000056   EE           MOV     A,R6
   \   000057   F9           MOV     R1,A
   \   000058   7F01         MOV     R7,#0x1
   \   00005A   02....       LJMP    ?BANKED_LEAVE_XDATA
    895          }
    896          
    897          
    898          
    899          
    900          
    901          /**************************************************************************************************
    902           * @fn      halProcessKeyInterrupt
    903           *
    904           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    905           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    906           *
    907           * @param
    908           *
    909           * @return
    910           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    911          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    912          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    913            bool valid=FALSE;
    914          
    915            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)  /* Interrupt Flag has been set */
   \   000004   E589         MOV     A,0x89
   \   000006   A2E5         MOV     C,0xE0 /* A   */.5
   \   000008   500C         JNC     ??CrossCallReturnLabel_15
    916            {
    917              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT); /* Clear Interrupt Flag */
   \   00000A   7589DF       MOV     0x89,#-0x21
    918          #ifndef HAL_KEY_LONG_SHORT_DISTINGUISH
    919              valid = TRUE;
    920          #else
    921              if (HalKeyGetEdge(0) ^ PUSH1_SBIT)
    922              {
    923          	  valid = TRUE;
    924          	}
    925          #endif
    926            }
    927          
    928          #ifndef KEY_PUSH_PORT_0_BUTTON
    929            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)  /* Interrupt Flag has been set */
    930            {
    931              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT); /* Clear Interrupt Flag */
    932              valid = TRUE;
    933            }
    934          #endif
    935          
    936          #ifdef KEY_PUSH_PORT_1_BUTTON
    937            if(HAL_KEY_PORT_1_PXIFG & HAL_KEY_PORT_1_BITS)
    938            {
    939              HAL_KEY_PORT_1_PXIFG &= ~HAL_KEY_PORT_1_BITS;
    940          #ifndef HAL_KEY_LONG_SHORT_DISTINGUISH
    941              valid = TRUE;
    942          #else
    943              if ((!!HalKeyGetEdge(1)) ^ (!HAL_KEY_PUSH_PORT_1_BUTTON()))
    944              {
    945                valid = TRUE;
    946              }
    947          #endif
    948            }
    949          #endif
    950          
    951            if (valid)
    952            {
    953              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
   \   00000D                ; Setup parameters for call to function osal_start_timerEx
   \   00000D   7C19         MOV     R4,#0x19
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7A01         MOV     R2,#0x1
   \   000013   12....       LCALL   ?Subroutine6 & 0xFFFF
    954            }
    955          }
   \                     ??CrossCallReturnLabel_15:
   \   000016   02....       LJMP    ??Subroutine11_0 & 0xFFFF
   \   000019                REQUIRE P0IFG
    956          
    957          /**************************************************************************************************
    958           * @fn      HalKeyEnterSleep
    959           *
    960           * @brief  - Get called to enter sleep mode
    961           *
    962           * @param
    963           *
    964           * @return
    965           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    966          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    967          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    968          }
   \   000000   02....       LJMP    ?BRET
    969          
    970          /**************************************************************************************************
    971           * @fn      HalKeyExitSleep
    972           *
    973           * @brief   - Get called when sleep is over
    974           *
    975           * @param
    976           *
    977           * @return  - return saved keys
    978           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    979          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    980          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    981            /* Wake up and read keys */
    982            return ( HalKeyRead () );
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   12....       LCALL   ??HalKeyRead?relay
   \   000007   02....       LJMP    ??Subroutine11_0 & 0xFFFF
    983          }
    984          
    985          /***************************************************************************************************
    986           *                                    INTERRUPT SERVICE ROUTINE
    987           ***************************************************************************************************/
    988          
    989          /**************************************************************************************************
    990           * @fn      halKeyPort0Isr
    991           *
    992           * @brief   Port0 ISR
    993           *
    994           * @param
    995           *
    996           * @return
    997           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    998          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
   \                     halKeyPort0Isr:
    999          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
   1000            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
   1001          
   1002            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)
   \   00000E   E589         MOV     A,0x89
   \   000010   A2E5         MOV     C,0xE0 /* A   */.5
   \   000012   5003         JNC     ??halKeyPort0Isr_0
   1003            {
   1004              halProcessKeyInterrupt();
   \   000014                ; Setup parameters for call to function halProcessKeyInterrupt
   \   000014   12....       LCALL   ??halProcessKeyInterrupt?relay
   1005            }
   1006          
   1007            /*
   1008              Clear the CPU interrupt flag for Port_0
   1009              PxIFG has to be cleared before PxIF
   1010            */
   1011            HAL_KEY_SW_6_PXIFG = 0;
   \                     ??halKeyPort0Isr_0:
   \   000017   758900       MOV     0x89,#0x0
   1012            HAL_KEY_CPU_PORT_0_IF = 0;
   \   00001A   C2C5         CLR     0xc0.5
   1013            
   1014            CLEAR_SLEEP_MODE();
   1015            HAL_EXIT_ISR();
   \   00001C   EE           MOV     A,R6
   \   00001D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001F   92AF         MOV     0xa8.7,C
   1016          }
   \   000021   7F01         MOV     R7,#0x1
   \   000023   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000026                REQUIRE _A_IEN0
   \   000026                REQUIRE P0IFG
   \   000026                REQUIRE _A_IRCON

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??halKeyPort0Isr??INTVEC 107`:
   \   00006B   02....       LJMP       (halKeyPort0Isr)

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_384:
   \   000000   84030000     DD 900

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyCountPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyCountPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLongKeyListener?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLongKeyListener

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halGetKeyCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halGetKeyCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??set_keys_id?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    set_keys_id

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_keys_id?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_keys_id

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halGetJoyKeyInput?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halGetJoyKeyInput

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep
   1017          
   1018          #ifdef KEY_PUSH_PORT_1_BUTTON
   1019          /**************************************************************************************************
   1020           * @fn      halKeyPort1Isr
   1021           *
   1022           * @brief   Port1 ISR
   1023           *
   1024           * @param
   1025           *
   1026           * @return
   1027           **************************************************************************************************/
   1028          HAL_ISR_FUNCTION( halKeyPort1Isr, P1INT_VECTOR )
   1029          {
   1030            HAL_ENTER_ISR();
   1031          
   1032            if (HAL_KEY_PORT_1_PXIFG & HAL_KEY_PORT_1_BITS)
   1033            {
   1034              halProcessKeyInterrupt();
   1035            }
   1036          
   1037            /*
   1038              Clear the CPU interrupt flag for Port_1
   1039              PxIFG has to be cleared before PxIF
   1040            */
   1041            HAL_KEY_PORT_1_PXIFG = 0;
   1042            HAL_KEY_CPU_PORT_1_IF = 0;
   1043            
   1044            CLEAR_SLEEP_MODE();
   1045            HAL_EXIT_ISR();
   1046          }
   1047          #endif
   1048          
   1049          #ifndef KEY_PUSH_PORT_0_BUTTON
   1050          /**************************************************************************************************
   1051           * @fn      halKeyPort2Isr
   1052           *
   1053           * @brief   Port2 ISR
   1054           *
   1055           * @param
   1056           *
   1057           * @return
   1058           **************************************************************************************************/
   1059          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
   1060          {
   1061            HAL_ENTER_ISR();
   1062            
   1063            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)
   1064            {
   1065              halProcessKeyInterrupt();
   1066            }
   1067          
   1068            /*
   1069              Clear the CPU interrupt flag for Port_2
   1070              PxIFG has to be cleared before PxIF
   1071              Notes: P2_1 and P2_2 are debug lines.
   1072            */
   1073            HAL_KEY_JOY_MOVE_PXIFG = 0;
   1074            HAL_KEY_CPU_PORT_2_IF = 0;
   1075          
   1076            CLEAR_SLEEP_MODE();
   1077            HAL_EXIT_ISR();
   1078          }
   1079          #endif
   1080          
   1081          #else
   1082          
   1083          
   1084          void HalKeyInit(void){}
   1085          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
   1086          uint8 HalKeyRead(void){ return 0;}
   1087          void HalKeyPoll(void){}
   1088          
   1089          #endif /* HAL_KEY */
   1090          
   1091          
   1092          
   1093          
   1094          
   1095          /**************************************************************************************************
   1096          **************************************************************************************************/
   1097          
   1098          
   1099          

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     HalKeyConfig                    0      0      9
       -> osal_stop_timerEx          0      0     18
       -> osal_set_event             0      0     18
     HalKeyCountPoll                 2      0      0
       -> osal_start_timerEx         4      0      0
       -> osal_GetSystemClock        4      0      0
       -> osal_start_timerEx         4      0      0
       -> osal_start_timerEx         4      0      0
     HalKeyEnterSleep                0      0      0
     HalKeyExitSleep                 2      0      0
       -> HalKeyRead                 4      0      0
     HalKeyInit                      2      0      0
     HalKeyPoll                      0      0     12
       -> osal_GetSystemClock        0      0     24
       -> osal_GetSystemClock        0      0     24
       -> osal_stop_timerEx          0      0     24
       -> osal_stop_timerEx          0      0     24
       -> set_keys_id                0      0     24
       -> osal_start_timerEx         0      0     24
     HalKeyRead                      0      0      0
     HalLongKeyListener              2      0      0
     get_keys_id                     0      0      0
     halGetJoyKeyInput               0      0      9
       -> HalAdcRead                 0      0     18
     halGetKeyCount                  2      0      0
     halKeyPort0Isr                 15      0      0
       -> halProcessKeyInterrupt    30      0      0
     halProcessKeyInterrupt          2      0      0
       -> osal_start_timerEx         4      0      0
     set_keys_id                     0      0     22


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_P0                             1
     P0IFG                             1
     PICTL                             1
     _A_IEN0                           1
     P0IEN                             1
     _A_IEN1                           1
     _A_IRCON                          1
     P0SEL                             1
     P0DIR                             1
     halKeySavedKeys                   2
     pHalKeyProcessFunction            2
     HalKeyConfigured                  1
     Hal_KeyIntEnable                  1
     preKeyClock                       4
     currentKeyClock                   4
     constantKeyCount                  1
     countEnd                          1
     KeyCount                          1
     mKeys                             2
     keyID                            32
     HalKeyInit                       66
     ?Subroutine0                      1
     ??Subroutine11_0                  7
     HalKeyConfig                     80
     ?Subroutine5                      2
     ??Subroutine7_0                   9
     HalKeyRead                       13
     HalKeyPoll                      183
     ?Subroutine6                      2
     ??Subroutine8_0                   9
     ?Subroutine4                      3
     ??Subroutine9_0                   7
     ?Subroutine2                      3
     ??Subroutine10_0                  8
     countDown                         1
     HalKeyCountPoll                 139
     ?Subroutine3                     17
     HalLongKeyListener               43
     halGetKeyCount                   12
     set_keys_id                     123
     ?Subroutine1                     17
     get_keys_id                       7
     halGetJoyKeyInput                93
     halProcessKeyInterrupt           25
     HalKeyEnterSleep                  3
     HalKeyExitSleep                  10
     halKeyPort0Isr                   38
     ??halKeyPort0Isr??INTVEC 107      3
     __Constant_0                      4
     __Constant_384                    4
     ??HalKeyInit?relay                6
     ??HalKeyConfig?relay              6
     ??HalKeyRead?relay                6
     ??HalKeyPoll?relay                6
     ??HalKeyCountPoll?relay           6
     ??HalLongKeyListener?relay        6
     ??halGetKeyCount?relay            6
     ??set_keys_id?relay               6
     ??get_keys_id?relay               6
     ??halGetJoyKeyInput?relay         6
     ??halProcessKeyInterrupt?relay    6
     ??HalKeyEnterSleep?relay          6
     ??HalKeyExitSleep?relay           6

 
 882 bytes in segment BANKED_CODE
  78 bytes in segment BANK_RELAYS
   3 bytes in segment INTVEC
  38 bytes in segment NEAR_CODE
   9 bytes in segment SFR_AN
   8 bytes in segment XDATA_ROM_C
  52 bytes in segment XDATA_Z
 
 998 bytes of CODE  memory (+ 3 bytes shared)
   0 bytes of CONST memory (+ 8 bytes shared)
   0 bytes of DATA  memory (+ 9 bytes shared)
  52 bytes of XDATA memory

Errors: none
Warnings: none
